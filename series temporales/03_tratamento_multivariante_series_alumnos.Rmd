---
title: "Tratamento multiariante de series"
author: "Servizo de Modelización"
date: "2025-06-27"
output: html_document
---

## Test de causalidade de Granger

Testea a capacidade de predecir unha serie a partir de outra

Se desexa coñecer se a serie x serve para predecir a serie y. Para isto compáranse os dous modelos

$y_{t} \sim y_{t-1}+x_{t-1}$

$y_{t} \sim y_{t-1}$

Constrúese un test de Wald para ambos, a hipotese nula é x non causa-Grager en Y. De xeito que se p\<0.05, rexeitase a hipotese nula e deducese que x serve para predecir y

Empregase a función *grangertest* da libreria lmtest

grangertest(x, y, order = 1, na.action = na.omit, ...)

order= retardo a incluir no regresión (por defecto é 1)

#### Exemplo. IPI serve para predecir PIB?

Léense as series do IPI(Base) e do PIB (Revisión estatísica 2024)

```{r}
rm(list=ls())
library(lmtest)
library(tidyr)
# PIB: datos brutos, ciclotendencia e correxidos de estacionalidade
pib <- read.csv("https://www.ige.gal/igebdt/igeapi/csv/datosserc/PIBRE24CORRBR/PIBRE24CORRCT/PIBRE24CORRSA")
pib<-pivot_wider(pib,names_from='serie',values_from='dato')
pib <- ts(pib[,3:5], start=c(1995,1), frequency=4)
# vemos como son os nomes das series e cambianse
colnames(pib)
colnames(pib)<-c("datos_br","ciclo_tend","datos_sa")

# IPI: Índice xeral. Base 2021  (mensual):
ipi <- read.csv("https://www.ige.gal/igebdt/igeapi/csv/datosserc/IPI21XE/IPI21XE%26ZZA/IPI21XE%26ZZT")
ipi<-pivot_wider(ipi,names_from='serie',values_from = 'dato')
ipi <- ts(ipi[,3:5], start=c(2002,1), frequency=12)
# calculase a media trimestral
ipi <- aggregate(ipi, nfrequency=4, mean)

# vemos como son os nomes das series e cambianse
colnames(ipi)
colnames(ipi)<-c("datos_br","datos_sa","ciclo_tend")
ipi2 <- ts(ipi, start=c(2002,1), end=c(2019,3), frequency = 4)

# período común
start(pib)
end(pib)

start(ipi)
end(ipi)


# período común: filtramos pib dende o 2002
pib<-window(pib,start=2002)


```

Representanse gráficamente as series (descompostas).

```{r}
plot(pib)
plot(ipi)

```

O índice e o pib teñen diferentes unidades de medida e non ten moito sentido representar as tendencias xuntas.

Calculase o test e causalidade de Granger entre os datos brutos. Non se pode rexeitar a hipótese nula

```{r}
grangertest(ipi[,"datos_br"], pib[,"datos_br"], order=1)
grangertest(ipi[,"datos_br"], pib[,"datos_br"], order=2)
grangertest(ipi[,"datos_br"], pib[,"datos_br"], order=3)
grangertest(ipi[,"datos_br"], pib[,"datos_br"], order=4)
?grangertest
```

Aplicamos os mesmos test entre as series de ciclotendencia e as series desestacionalizadas. Non se pode rexeitar a hipótese nula

```{r}
grangertest(ipi[,"ciclo_tend"], pib[,"ciclo_tend"], order=1)
grangertest(ipi[,"ciclo_tend"], pib[,"ciclo_tend"], order=2)
grangertest(ipi[,"ciclo_tend"], pib[,"ciclo_tend"], order=3)
grangertest(ipi[,"ciclo_tend"], pib[,"ciclo_tend"], order=4)

```

```{r}
grangertest(ipi[,"datos_sa"], pib[,"datos_sa"], order=1)
grangertest(ipi[,"datos_sa"], pib[,"datos_sa"], order=2)
grangertest(ipi[,"datos_sa"], pib[,"datos_sa"], order=3)
```

#### Exercicio

Descargar o Valor Engadido Bruto da industria (datos brutos, correxidos de estacionalidade e ciclotendencia). Representar gráficamente. Aplicar o test de Granger para determinar se o IPI industrial se pode empregar para estimar o VEB na industria

```{r}
veb <- read.csv('https://www.ige.gal/igebdt/igeapi/csv/datosserc/VEB1002CORBR/VEB1002CORCT/VEB1002CORSA')
veb <- pivot_wider(veb, names_from = 'serie', values_from = 'dato')
ipi2
veb <- ts(veb, start = c(2002,1), frequency = 4)
colnames(ipi2)<-c("datos_br","datos_sa","ciclo_tend")

grangertest(ipi2[,"datos_sa"], veb[,"VEB1002CORBR"], order=1)
grangertest(ipi[,"datos_sa"], veb[,"datos_sa"], order=2)
grangertest(ipi[,"datos_sa"], veb[,"datos_sa"], order=3)
ipi <- window(ipi, end=2019)

```

#### Exercicio

Descargar o PIB en índices de volume (datos brutos, correxidos de estacionalidade e ciclotendencia). Representar gráficamente as series descompostas e as series por compoñentes.

Aplicar o test de Granger para determinar se o ipi se pode empregar para estimar o VEB na industria

```{r}
pib2<-read.csv('https://www.ige.gal/igebdt/igeapi/csv/datosserc/PIB10CORRBR/PIB10CORRCT/PIB10CORRSA')
pib2<- pib2 %>% pivot_wider(names_from='serie', values_from = 'dato')
pib2 <- select(pib2,"PIB10CORRBR", "PIB10CORRCT", "PIB10CORRSA")

colnames(pib2)
colnames(pib2) <- c('bruto','ciclo2','nosta')
pib2<-ts(pib2,start=c(2002,1),frequency = 4)
grangertest(ipi2[,"datos_sa"], pib2[,"bruto"], order=1)
grangertest(ipi2[,"datos_sa"], pib2[,"ciclo2"], order=2)
grangertest(ipi2[,"datos_sa"], pib2[,"nosta"], order=3)
plot(pib2)
```

#### Exercicio

Idem anteriores co Indice por destino dos bens. Bens de consumo e o gasto en consumo final dos fogares e das IPSFL (índices de volume)

indice confianza a nivel España y Pib españa

```{r}

```

## Test de raíz unitaria (Augmented Dickey-Fuller Test)

Contrastar se unha serie ten raíz unitaria (é un AR(1) con coeficiente=1) e polo tanto de tendencia estocástica. A alternativa H1: será que é un proceso estacionario

Empregase a función *adf.test* da libreria tseries. É un test dunha sola cola polo que se rexeita para valores inferiores a 0,05 ao 95% de confianza.

Pode contrastarse que a raíz sexa menor que 1 (proceso estacionario) ou que a raiz sexa maior que 1 (proceso explosivo). Por defecto contrasta raíz unitaria fronte a raiz menor que 1.

```{r}
library(tseries)
serieNormal<-ts(rnorm(120),start=2000,frequency = 12)
plot(serieNormal)
test<-adf.test(serieNormal)
?adf.test
print(test)
```

Na serie creada na anterior clase con deriva=0.25. Da un p-value de 0.29 polo que NON se pode rexeitar a hipotese nula

```{r}
set.seed(23556)
tendest <- 50 +                 # y_0
           1:80 * 0.25 +        # t * m
           cumsum(rnorm(80))    # e_1 + e_2 + ... + e_t
tendest <- ts(tendest, start=c(2000,1), freq=4)

# no es estacionario
plot(tendest)

test<-adf.test(tendest)
print(test)

```

#### Exercicio

Aplicar o test de raíz unitaria para a serie anterior, despois de tomar diferenzas

```{r}
dif <- diff(tendest)
adf.test(dif)
```

#### Exercicio

Aplicar o test de raíz unitaria para a ciclotendencia do PIB, do IPI xeral, do VAB da industria do IPI bens de consumo e do gasto en consumo final

```{r}
adf.test(ts(pib2[,'ciclo2'], frequency = 4))
adf.test(ts(ipi[,'IPI21XE'], frequency = 4))
adf.test(ts(veb[,'VEB1002CORBR'], frequency = 4))
adf.test(ts(gasto[,'dato'],frequency = 4))

```

## Problema da regresión espúrea

Dúas series con raíz unitaria poden presentar un bó nivel de axuste nunha regresión aínda que non garden relación

Por exemplo, creanse dúas series con raíz unitaria independentes e axustase por MCO; estas presentan unha elevada bondade de axuste a pesar de seren independentes

```{r}
set.seed(12345)
y       <- 50 +                  # y_0
           1:100 * 0.8 +         # t * m
           cumsum(rnorm(100))    # e_1 + e_2 + ... + e_t

x       <- 50 +                  # y_0
           1:100 * 0.6 +         # t * m
           cumsum(rnorm(100))    # e_1 + e_2 + ... + e_t

# representanse gráficamente    
plot(y,col='blue',type='l',main="regresión espúrea")
lines(x,col='red')
legend("top",legend=c("y","x"),col=c("blue","red"),lty=1)

#ambas series presentan una raíz unitaria
adf.test(y)
adf.test(x)
    
    #d# El grado de ajuste es próximo a 1
mco <- lm(y~x)
summary(mco)

```

Estas series facilitan un coeficiente de axuste de 0.98

Os residuos dunha regresión espúrea presentan unha raíz unitaria. Isto é o que nos permite identificalas

```{r}
# representación dos residuos
plot(mco$residuals)

# test de raiz unitaria para os residuos
adf.test(mco$residuals)


```

## Cointegración

A cointegración é importante en econometría xa que permite identificar relacións a longo plazo entre variables que en principio poderían parecer non relacionadas. Duas series están cointegradas se presentan unha tendencia estocástica común e polo tanto ao combinarse son estacionarias.

Método Engle-Granger de dous pasos : Se $x_{t}$ e $y_{t}$ son non estacionarias **e cointegradas**, entonces unha combinación lineal de elas debe ser estacionaria.

Polo tanto, facendo a regresión (unha sobre a outra) os residuos deben ser estacionarios (a diferenza das regresións espúreas nas que os residuos non son estacionarios).

Así pois, se dúas series presentan dúas raices unitarias debería facerse unha regresión entre as series diferenciadas; máis se están cointegradas pode facerse entre elas xa que comparten a tendencia estocástica.

Exemplo: cointegración entre o log(PIB) e o log(Consumo)

```{r}
library(tidyverse)

#CONSUMO
consumo <- read.csv("https://www.ige.gal/igebdt/igeapi/csv/datosserc/GCFADRE24CORBR/GCFADRE24CORCT/GCFADRE24CORSA/GCFFORE24CORBR/GCFFORE24CORCT/GCFFORE24CORSA");
consumo <- pivot_wider(consumo, names_from="serie", values_from="dato")
consumo<-consumo%>%
  arrange(codtempo)%>%
  mutate(cons_br=GCFADRE24CORBR+GCFFORE24CORBR,
            cons_tend=GCFADRE24CORCT+GCFFORE24CORCT,
            cons_sa=GCFADRE24CORSA+GCFFORE24CORSA,.keep="none")
consumo_ts <- ts(consumo, start=c(1995,1), frequency = 4)

#PIB
pib<-read.csv("https://www.ige.gal/igebdt/igeapi/csv/datosserc/PIBRE24CORRBR/PIBRE24CORRCT/PIBRE24CORRSA")
pib<-pib%>%pivot_wider(names_from='serie',values_from='dato')%>%arrange(codtempo)
pib_ts<-ts(pib[,3:5],start=1995, frequency = 4)
colnames(pib_ts)<-c("pib_br","pib_tend","pib_sa")

# collemos anos pre-covid
consumo_ts <- window(consumo_ts, start=c(1995, 1), end=c(2019,4))
pib_ts <- window(pib_ts, start=c(1995, 1), end=c(2019,4))

# logaritmos
pib_log<-log(pib_ts)
cons_log<-log(consumo_ts)


# representanse gráficamente    
plot(cons_log[,"cons_br"],col='blue',type='l',main="Consumo final e PIB",ylim=c(15,17))
lines(pib_log[,"pib_br"],col='red')
legend("bottomright",legend=c("log(consumo)","log(pib)"),col=c("blue","red"),lty=1)

```

As dúas series parecen ter tendencia estocástica. Comprobase se teñen raices unitarias

```{r}
        #f_4# Ambas presentan raíces unitarias
adf.test(pib_log[,"pib_br"])
adf.test(cons_log[,"cons_br"])

```

Non se pode rexeitar a hipótese nula. Para ver se estan cointegradas faise a regresion dunha sobre a outra e aplicaselle o test de raíz unitaria aos residuos.


```{r}
datos<-ts.union(cons_log,pib_log)
colnames(datos)<-c(colnames(cons_log),colnames(pib_log))
mco <- lm(cons_br~ pib_br,datos)

residuos<-mco$residuals
plot(residuos)
adf.test(residuos)

```
```{r}
grangertest(veb[,"VEB1002CORBR"], ipi2[,"datos_br"], order=1)
veb_log<-log(veb)
ipi_log<-log(ipi2)
veb_log
ipi_log
# representanse gráficamente    
plot(veb_log[,"VEB1002CORBR"],col='blue',type='l',main="VEB",ylim=c(0,17))
lines(ipi_log[,"datos_br"],col='red')
legend("bottomright",legend=c("log(VEB)","log(IPI)"),col=c("blue","red"),lty=1)

datos<-ts.union(veb_log,ipi_log)
colnames(datos)<-c(colnames(veb_log),colnames(ipi_log))
mco <- lm(VEB1002CORBR~ datos_br,datos)

residuos<-mco$residuals
plot(residuos)
adf.test(residuos)
```

O test non permite rexeitar a hipotese nula e polo tanto a regresión é espúrea (xa que as series non están cointegradas)

En Galicia non hai cointegración.

## 
