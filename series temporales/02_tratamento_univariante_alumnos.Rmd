---
title: "Tratamento univariante nas series"
author: "Servizo de modelización"
date: "2025-06-24"
output: html_document
---

## Descomposición dunha serie económica en compoñentes

A teoría clásica de series temporales consiste en descompoñer a estrutura das series en:

\- **tendencia** $u_{t}$: copoñenente xeral ou movemento a longo prazo da serie

\- **variacións cíclicas** $c_{t}$: variacións en torno á tendencia que se producen en períodos superiores ao ano (por exemplo nas series económicas as variacións poderían estar debidas a alternancia de etapas de prosperidade e depresión). Na práctica resulta moi dificil diferenciar entre ciclo e tendencia

\- **variacións estacionais** $s_{t}$**:** variacións con período inferior ou igual ao ano

\- **variacións residuais** ( $r_{t}$compoñente irregular): recollen un sinfín de causas, son variacións que pola súa impredecibilidade poden considerarse variables aleatorias independientes.

Xuntando estas compoñentes poden obterse os distintos modelos; no aditivo estas compoñentes aparecen sumadas

$X_{t}=u_{t}+c_{t}+s_{t}+r_{t}$

### Crear unha serie artificialmente

No seguinte chunk crease unha serie con estas compoñentes. Para simular o ciclo empregarase

$f(x)=A.cos(Bx)$

A amplitude

B frecuencia: número de ciclos en 2 $\pi$ radiantes=\>período=$2\pi/B$

```{r}
library(tidyr)
# 20 años x 4 trimestres = 80 trimestres
t <- 1:80

# 1) Tendencia lineal, crecimiento a largo plazo
tende <- 50 + 0.3 * t

# 2) Ciclo: Modelizase cunha función trigonométrica:
#    Por ejemplo: amplitud * cos(punto/s * 2pi / período)
ciclo <- 3 * cos(t * 2*pi / 32) # período 8 años, 32 trimestres 
    #    plot(ciclo). Probar con diferentes períodos: cos(t * 2*pi / 8)

    # 3) Estacionalidad: 
    #    4 trimestres * 20 años
    #    Suman 0
estac <- rep(c(-1,1,2,-2), 20)

    # 4) Componente irregular: Ruido blanco. Incorrelados
set.seed(1234)
irreg <- rnorm(80) 

    # Combinamos los componentes aditivamente en la serie final
    # Podrían entrar algunos multiplicando...
serie <- tende + ciclo + estac + irreg
artif01 <- ts(cbind(tende, ciclo, estac, irreg, serie), start = c(2000,1), frequency=4)
plot(artif01)

```

No seguinte chunk crease outra serie pero coa tendencia calculada acumulando o producto. O primeiro valor é 25 e os restantes obteñense multiplicando o anterior por 1,02

```{r}

tende <- cumprod( c(25, rep(1.02, 79)) )
#tende <- 25 * cumprod(c(1.0, rep(1.02, 79)))
serie <- tende + ciclo + estac + irreg
artif02 <- ts(cbind(tende, ciclo, estac, irreg, serie), start = c(2000,1), frequency=4)
plot(artif02)


```

Non sempre se pode separar o ciclo da tendencia

```{r}
ciclo <- 5 * cos(t * 2*pi / 40) # período 10 años, 40 trimestres 
ciclotendencia<-tende+ciclo
serie <- ciclotendencia + estac + irreg
artif03 <- ts(cbind(ciclotendencia,estac, irreg, serie), start = c(2000,1), frequency=4)
plot(artif03)
```

### Series publicadas

#### Datos brutos, ciclotendencia e estacionalidade

Na web do IGE, no Banco de series de conxuntura pode descargarse a serie do Produto Interior Bruto a prezos de mercado (PIBpm) Revisión estatística 2024. Esta serie publícase en datos brutos, ciclo-tendencia e datos correxidos de estacionalidade:

```{r}
pib <- read.csv("https://www.ige.gal/igebdt/igeapi/csv/datosserc/PIBRE24CORRBR/PIBRE24CORRCT/PIBRE24CORRSA")
pib <- pivot_wider(pib, names_from="serie", values_from="dato") 
pib <- ts(pib[,3:5], start = c(1995,1), frequency=4)
colnames(pib) <- c("brutos", "ciclo_tend", "desestac")

# a compoñente estacional será polo tanto
pib<-cbind(pib,pib[,"brutos"]-pib[,"desestac"])


colnames(pib) <- c("brutos", "ciclo_tend", "desestac","estac")
plot(pib)
```

O comando *decompose* permite descomponer unha serie nas compoñentes tendencia (ciclotendencia)+ estacional+aleatoria. A descomposición faise mediante un axuste de medias moviles. O compoñente estacional pode ser aditivo ou multiplicativo

decompose(x, type = c("additive", "multiplicative"), filter = NULL)

```{r}
pib_d<-decompose(pib[,3])
plot(pib_d)

```

```{r}
class(pib_d)

pib_d$x%>%window(start=1996,end=c(1996,4))
pib_d$trend%>%window(start=1996,end=c(1996,4))
pib_d$seasonal%>%window(start=1996,end=c(1996,4))
pib_d$random%>%window(start=1996,end=c(1996,4))

```

Representación gráfica das compoñentes

```{r}
# Tendencia
plot(pib[,"ciclo_tend"],col='blue',ylab='Euros')
lines(pib_d$trend,col='red')
legend("bottomleft",legend=c("PIB ciclotendenncia","tendencia axustada descomposse"),col=c("blue","red"),lty=1)
```

```{r}
# estacional
plot(pib[,"estac"],col='blue',ylab='Euros')
lines(pib_d$seasonal,col='red')
legend("bottomleft",legend=c("PIB estacional","estacional axustada descomposse"),col=c("blue","red"),lty=1)
```

#### Exercicio

Aplicar o método *decompose* a las tres series creadas artificialmente. Representar gráficamente as compoñentes estacionais e a ciclotendencia

```{r}
artif01_d=decompose(artif01[,'serie'])
par(mfrow = c(1,2))
plot(artif01[,'ciclo']+artif01[,'tende'],col='red')
plot(artif01_d[['trend']], col='green')

artif02_d=decompose(artif02[,'serie'])
plot(artif02[,'ciclo']+artif02[,'tende'], col='red')
plot(artif02_d[['trend']], col='green')

artif03_d=decompose(artif03[,'serie'])
plot(artif03[,'ciclotendencia'], col='red')
plot(artif03_d[['trend']], col='green')
par(mfrow = c(1,1))
```

#### Prezos correntes e prezos reais

Os datos do PIB publicados na web do IGE están expresados en prezos correntes. En series de magnitudes económicas é mellor traballar con prezos reais (eliminando a influenza da subida dos prezos).

Para pasar de prezos correntes a reais (en € do período de referencia, ano 2020), empréganse os índices de volume e así

Pib real=Pib ano de referencia\*indice/100

-   Leense os datos brutos do Produto Interior Bruto pm: prezos correntes e índices de volume:

```{r}

pibreal <- read.csv("https://www.ige.gal/igebdt/igeapi/csv/datosserc/PIBRE24CONSBR/PIBRE24CORRBR")
head(pibreal)
pibreal <- pivot_wider(pibreal, names_from="serie", values_from="dato") 
pibreal <- ts(pibreal[,3:4], start = c(1995,1), frequency=4)
colnames(pibreal) <- c("ind", "corr")
plot(pibreal)

```

-   calcúlase o PIB medio anual no ano base; i.e. a media anual do PIB en prezos correntes para o ano 2020

```{r}
ref2020 <- mean( window(pibreal[,"corr"], start=c(2020,1), end=c(2020,4)) )
print(ref2020) 
```

-   Calculase a serie de pib a prezos reais:

```{r}

pibreal <- cbind(pibreal, pibreal[,"ind"] * ref2020 / 100)
colnames(pibreal) <- c("ind", "corr", "real")


# GRÁFICO
plot(pibreal[,"corr"],col='blue',main='PIB pm prezos correntes e reais')
lines(pibreal[,"real"],col='red')
legend("bottomleft",legend=c("PIBpm correntes","PIBpm reais"),col=c("blue","red"),lty=1)
```

#### Exercicio.

Descompoñer a serie do pib real empregando descompose e graficala

Pasar o Gasto consumo dos fogares a termos reais e descompoñela

#### 

```{r}
plot(decompose(pibreal[,'real']))
gasto <- read.csv('https://www.ige.gal/igebdt/igeapi/csv/datosserc/GCFFORE24CORBR',
                  encoding='latin1')
gasto <- ts(gasto, frequency = 4, start = c(1995,1), end = c(2025,1),)
gasto
ref2020 <- mean( window(gasto[,"dato"], start=c(2020,1), end=c(2020,4)) )
ref2020
gasto <- cbind(gasto, pibreal[,"ind"] * ref2020 / 100)
```

```{r}

```

## JDemetra

Para desestacionalizar as series empregase JDemetra (programa da UE) implementa TRAMO_SEATS e X13_ARIMA_SEATS

Leese a serie de pernoitas en establecementos hoteleiros

```{r}
library(RJDemetra)
# leense todas as series de pernoitas
per <- read.csv("https://www.ige.gal/igebdt/igeapi/csv/datosserc/EOTRP_04/EOTRP_04%26ZZA/EOTRP_04%26ZZC/EOTRP_04%26ZZS/EOTRP_04%26ZZT")
per<-per%>%pivot_wider(names_from='serie',values_from='dato')

# pasamos a series de tempo
per <- ts(per[,3:7], start=c(1999, 1), frequency=12)
head(per)
colnames(per)<-c("pern","pern_SCT","pern_C","pern_SC","pern_ten")

# seleccionase dende 1999 ata 2019 das pernoitas
pernoitas <- window(per[,"pern"], start=c(1999,1), end=c(2019,12))
plot(pernoitas)

```

A función *tramoseats* estima a serie axustada estacionalmente (sa) co método TRAMO-SEATS. Isto conséguese descompoñendo a serie temporal (y) no ciclo de tendencia (t), o compoñente estacional (s) e o compoñente irregular (i). A serie axustada estacionalmente (sa) é a serie orixinal (y) sen o compoñente estacional (s)

```{r}
 # desestacionalizamos con TRAMO SEATS
pernoitas_sa <- tramoseats(pernoitas)
names(pernoitas_sa)
pernoitas_sa

```

```{r}

# a serie e as suas compoñentes esta na list "final" 
compoñentes<-pernoitas_sa["final"]$final[[1]]
# representacion gráfica
plot(compoñentes)

```

```{r}
# a serie sa é a serie orixinal despois de quitarlle a parte estacional
compoñentes[,"sa"]-(compoñentes[,"y"]-compoñentes[,"s"])

```

Para comparar cos datos baixados da web. Ollo, os datos do banco de conxuntura están correxidos de efectos calendario.

```{r}
#Se comparamos cos datos baixados da web: serie, correxida de estacionalidade, calendario e atipicos e tendencia
plot(per[,c(1,2,5)])
```

#### Exercicio

Aplicar tramoseats a pib en termos reais e ao gasto

```{r}
tramoseats(pibreal[,'real'])
plot(tramoseats(pibreal[,'real']))
```

### Filtros ciclo-tendencia

o paquete mFilter proporciona algunhas ferramentas para descompoñer series temporais en compoñentes de tendencia (suaves) e cíclicos (irregulares). O paquete implementa filtros de uso común como o filtro Hodrick-Prescott, Baxter-King, etc

### Hodrick-Prescott

Este método permite obter a ciclo-tendencia

```{r}
library(mFilter)
pib_hp <- hpfilter(pibreal[,"real"], freq=1600,type="lambda")
plot(pib_hp)
```

A función hpfilter devolve unha lista e dela pose sacarse a tendencia (\$trend) e o ciclo (\$cycle)

```{r}
head(pib_hp$trend)
head(pib_hp$cycle)

```

#### Baxter-King

Esta función implementa a aproximación de Baxter-King ao filtro de paso de banda para unha serie temporal. A función calcula os compoñentes cíclicos e de tendencia da serie temporal mediante a aproximación de paso de banda para filtros de lonxitude fixa e variable.

É parecido ao anterior; descompón a serie segundo as súas frecuencias e quédase coas frecuencias segundo establezamos nos parámetros

```{r}

pib_bk <- bkfilter(pibreal[,"real"], pl=8, pu=32)
plot(pib_bk)

```

```{r}

pib_bk <- bkfilter(pibreal[,"real"], 2, 32) 
plot(pib_bk)

```

### ARMA(p,q)

Un proceso ARMA(p,q) :

$X_{t}=a_{1}X_{t-1}+...+a_{p}X_{t-p}+e_{t}+b_{1}e{t-1}...b_{q}e{t-q}$​\

Un proceso ARIMA(p,d,q) $Z_{t}$ é aquel tal que $D^d(Z_{t})$ é ARMA(p,q)

Pasos na metodoloxía Box-Jenkins:

-   Identificación da estrutura no estacionaria =\> transformar o modelo a estacionario. As dúas transformacións básicas son:

    -   diferenzas: cando non hai estacionariedade en media

    -   logaritmos: cando non é estacionario en varianza (heterocedasticidade)

-   Identificación da estrutura ARMA. Para isto emprégase as autocorrelacións e as autocorrelacións parciais (identificar p e q ordes dos procesos autoregresivos e de medias moviles)

#### Series con tendencia estocástica: modelos AR(1) con raíz unitaria ($\phi=1$)

As series económicas modeladas como AR(1) e con raíz unitaria teñen tendencia estocástica debido a que a raíz é 1 (o pasado non se amortigua e xenera a tendencia). NON SON ESTACIONARIAS

Sexa un AR(1) definido como

$y_{t}=m+y_{t-1}+e_{t}$

partindo de $y_ {0}$ e sustituindo:

$y_{1}=m+y_{0}+e_{1}$

$y_{2}=m+y_{1}+e_{2}=m+(m+y_{0}+e_{1})+e_{2}=2m+y_{0}+e_{1}+e_{2}$

...

$y_{t}=tm+y_{0}+e_{1}+...+e_{t}$

o valor de m coñecese como deriva (drift)

No seguinte chunk imos simular un proceso destas características.

```{r}
set.seed(26062024)
tendest <- 50 +                 # y_0
           1:80 * 0.25 +        # t * m
           cumsum(rnorm(80))    # e_1 + e_2 + ... + e_t
tendest <- ts(tendest, start=c(2000,1), freq=4)

# no es estacionario
plot(tendest)
# las primeras diferencias si lo son ya que diff(y_t) = m + e_t
plot(diff(tendest))

```

```{r}
serie<-rnorm(80,100,20)*(1:80)
plot(serie,type='l')
log_serie<-log(serie)
plot(log_serie,type='l')
dif_log_serie<-diff(log_serie)
plot(dif_log_serie,type='l')


```

Para determinar a orde q (MA(q)) empregase as autocorrelacións e para determinar a orde p (AR(p)) empregánse as autocorrelacións

```{r}
serienormal<-rnorm(100)
pacf(serienormal)
acf(serienormal,type='partial')

```

No seguinte chunk crease un ARMA con AR(4)

```{r}
set.seed(1234)
y <- arima.sim(list(ar=c(0.4)), n=400)
acf(y)
pacf(y)


```

No seguinte chunk crease un ARIMA con MA(2)

```{r}
set.seed(1234)
y <- arima.sim(list(ma=c(0.2)), n=400)
acf(y)
pacf(y)


```

Estimase o modelo coa funcion arima; probase con distintas configuracións

```{r}
set.seed(1234)
y <- arima.sim(list(ar=c(0.4), ma=c(0.25)), n=400)
est_y <- arima(y, order=c(1,0,1))

est_y_bis <- arima(y, order=c(2,0,1))

```

#### Prediccións

Para facer predicións empregase a librería forecast

```{r}
library(forecast)

forec=forecast(est_y)

par(mfrow=c(1,1))
plot(y, col='peru')
lines(forec$mean,col='black')
```
